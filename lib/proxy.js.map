{"version":3,"sources":["proxy.js"],"names":[],"mappings":"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","file":"proxy.js","sourcesContent":["'use strict';\nimport config from 'config';\nimport path from 'path';\nimport errors from '@hoist/errors';\nimport Authorization from './authorization';\nimport fs from 'fs';\nimport redisLock from 'redis-lock';\nimport redis from 'redis';\nimport redisSentinel from 'redis-sentinel-client';\nimport moment from 'moment';\nimport {\n  filter,\n  isFunction\n}\nfrom 'lodash';\nimport {\n  BouncerToken\n}\nfrom '@hoist/model';\nimport logger from '@hoist/logger';\n\nfunction createRedisClient() {\n  if (config.has('Hoist.redis.clustered') && config.get('Hoist.redis.clustered')) {\n    return redisSentinel.createClient({\n      host: config.get('Hoist.redis.host'),\n      port: config.get('Hoist.redis.port'),\n      masterName: config.get('Hoist.redis.masterName')\n    });\n  } else {\n    return redis.createClient(config.get('Hoist.redis.port'), config.get('Hoist.redis.host'));\n  }\n}\n\n/**\n * a proxy class to the underlying connector\n */\nclass ConnectorProxy {\n\n  /**\n   * setup the connector proxy described by the {@link ConnectorSetting} object\n   * @param {ConnectorSetting} connectorSetting - the settings for the underlying connector\n   */\n  constructor(connectorSetting) {\n    this._logger = logger.child({\n      cls: this.constructor.name,\n      applicationId: connectorSetting.application,\n      connectorKey: connectorSetting.key\n    });\n    this._connectorSetting = connectorSetting;\n    let connectorsPath = path.resolve(config.get('Hoist.filePaths.connectors'));\n    let connectorPath = path.join(connectorsPath, connectorSetting.connectorType, 'current');\n    this._connectorPath = fs.realpathSync(connectorPath);\n    this._settings = this._connectorSetting.settings;\n  }\n\n  _refreshCredentials() {\n\n    //reload the connector settings to see if they've been refreshed\n    //only one server will go into this step at a time\n    let refreshed;\n    let client;\n    return Promise.resolve()\n      .then(() => {\n        if (!this._bouncerToken) {\n          throw new Error('Connector is not authorized');\n        }\n        client = createRedisClient();\n        return new Promise((resolve) => {\n          redisLock(client)(`connector-refresh-${this._connectorSetting._id}`, 10000, (done) => {\n            refreshed = done;\n            resolve();\n          });\n        });\n      }).then(() => {\n        return BouncerToken.findOneAsync({\n          _id: this._bouncerToken._id\n        });\n      }).then((latestBouncerToken) => {\n        if (moment(latestBouncerToken.updatedAt).isSame(moment(this._bouncerToken.updatedAt))) {\n          //rely on inbuilt update to credentials\n          return this._connector._refreshCredentials();\n        } else {\n          return this.authorize(latestBouncerToken);\n        }\n      }).then(() => {\n        refreshed();\n        if (client) {\n          client.quit();\n        }\n      }).catch((err) => {\n        this._logger.error(err);\n        this._logger.alert(err);\n        if (client) {\n          client.quit();\n          throw err;\n        }\n      });\n  }\n\n  /**\n   * initialize this proxy instance\n   * @param {Context} context - the current context\n   * @returns {Promise<ConnectorProxy>} - this proxy object to allow chaining\n   */\n  init(context) {\n    return Promise.resolve()\n      .then(() => {\n        let ConnectorType = require(this._connectorPath);\n        if (ConnectorType.default && isFunction(ConnectorType.default)) {\n          ConnectorType = ConnectorType.default;\n        }\n        this._connector = new ConnectorType(this._settings);\n        if (this._connector.refreshCredentials) {\n          this._connector._refreshCredentials = this._connector.refreshCredentials;\n          this._connector.refreshCredentials = () => {\n            return this._refreshCredentials();\n          };\n        }\n        let methods = filter(Object.getOwnPropertyNames(Object.getPrototypeOf((this._connector))), (property) => {\n          if (property.startsWith('_') || property === 'receiveBounce' || this[property] || property === 'constructor') {\n            return false;\n          } else {\n            return true;\n          }\n        });\n        this._logger.info({\n          connector: this._connector,\n          methods\n        }, 'mapping methods');\n        methods.forEach((method) => {\n          /**\n           * also has all methods of underlying connector\n           */\n          this[method] = (...params) => {\n            this._logger.info('proxying method ' + method);\n            if (typeof this._connector[method] !== 'function') {\n              let methodType = typeof this._connector[method];\n              this._logger.warn({\n                methodType\n              }, 'tried to call an unsupported method');\n              throw new errors.connector.request.UnsupportedError(method + ' method unsupported');\n            }\n            return this._connector[method].apply(this._connector, params);\n          };\n        });\n        if (context.bucket &&\n          context.bucket.meta &&\n          context.bucket.meta.authToken &&\n          context.bucket.meta.authToken[this._connectorSetting.key]) {\n          return this.authorize(context.bucket.meta.authToken[this._connectorSetting.key])\n            .catch((err) => {\n              this._logger.error(err);\n              if (err instanceof errors.connector.request.InvalidError) {\n                return this;\n              } else {\n                throw err;\n              }\n            });\n        } else {\n          return this;\n        }\n      });\n  }\n\n  /**\n   * authorize the underlying connector\n   * @param {Authorization|String} token - either the authorization object or a bouncer token key\n   * @returns {Promise<ConnectorProxy>} - this\n   */\n  authorize(token) {\n    if (typeof this._connector.authorize !== 'function') {\n      return Promise.resolve(this);\n    }\n    if (typeof token === 'string') {\n      return BouncerToken.findOneAsync({\n        key: token\n      }).then((bouncerToken) => {\n        if (!bouncerToken) {\n          throw new errors.connector.request.InvalidError('the authorization token provided is not valid');\n        }\n        this._bouncerToken = bouncerToken;\n        return this._connector.authorize(new Authorization(bouncerToken));\n      }).then(() => {\n        return this;\n      });\n    } else {\n      this._bouncerToken = token;\n      return Promise.resolve(this._connector.authorize(token))\n        .then(() => {\n          return this;\n        });\n    }\n  }\n}\n\nexport\ndefault ConnectorProxy;\n\n/**\n * @external {ConnectorSetting} https://github.com/hoist/hoist-model/blob/master/lib/models/connector_setting.js\n */\n/**\n * @external {Context} https://github.com/hoist/hoist-context/blob/master/lib/index.js\n */\n"],"sourceRoot":"/source/"}