{"version":3,"sources":["proxy.js"],"names":[],"mappings":"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","file":"proxy.js","sourcesContent":["'use strict';\nimport config from 'config';\nimport path from 'path';\nimport errors from '@hoist/errors';\nimport Authorization from './authorization';\nimport fs from 'fs';\nimport redisLock from 'redis-lock';\nimport redis from 'redis';\nimport redisSentinel from 'redis-sentinel-client';\nimport moment from 'moment';\nimport {\n  filter\n}\nfrom 'lodash';\nimport {\n  BouncerToken\n}\nfrom '@hoist/model';\nimport logger from '@hoist/logger';\n\nfunction createRedisClient() {\n  if (config.has('Hoist.redis.clustered') && config.get('Hoist.redis.clustered')) {\n    return redisSentinel.createClient({\n      host: config.get('Hoist.redis.host'),\n      port: config.get('Hoist.redis.port'),\n      masterName: config.get('Hoist.redis.masterName')\n    });\n  } else {\n    return redis.createClient(config.get('Hoist.redis.port'), config.get('Hoist.redis.host'));\n  }\n}\n\n/**\n * a proxy class to the underlying connector\n */\nclass ConnectorProxy {\n\n  /**\n   * setup the connector proxy described by the {@link ConnectorSetting} object\n   * @param {ConnectorSetting} connectorSetting - the settings for the underlying connector\n   */\n  constructor(connectorSetting) {\n    this._logger = logger.child({\n      cls: this.constructor.name,\n      applicationId: connectorSetting.application,\n      connectorKey: connectorSetting.key\n    });\n    this._connectorSetting = connectorSetting;\n    let connectorsPath = path.resolve(config.get('Hoist.filePaths.connectors'));\n    let connectorPath = path.join(connectorsPath, connectorSetting.connectorType, 'current');\n    this._connectorPath = fs.realpathSync(connectorPath);\n    this._settings = this._connectorSetting.settings;\n  }\n\n  _refreshCredentials() {\n\n    //reload the connector settings to see if they've been refreshed\n    //only one server will go into this step at a time\n    let refreshed;\n    let client;\n    return Promise.resolve()\n      .then(() => {\n        if (!this._bouncerToken) {\n          throw new Error('Connector is not authorized');\n        }\n        client = createRedisClient();\n        return new Promise((resolve) => {\n          redisLock(client)(`connector-refresh-${this._connectorSetting._id}`, 10000, (done) => {\n            refreshed = done;\n            resolve();\n          });\n        });\n      }).then(() => {\n        return BouncerToken.findOneAsync({\n          _id: this._bouncerToken._id\n        });\n      }).then((latestBouncerToken) => {\n        if (moment(latestBouncerToken.updatedAt).isSame(moment(this._bouncerToken.updatedAt))) {\n          //rely on inbuilt update to credentials\n          return this.connector._refreshCredentials();\n        } else {\n          return this.authorize(latestBouncerToken);\n        }\n      }).then(() => {\n        refreshed();\n        client.quit();\n      }).catch((err) => {\n        client.quit();\n        throw err;\n      });\n  }\n\n  /**\n   * initialize this proxy instance\n   * @param {Context} context - the current context\n   * @returns {Promise<ConnectorProxy>} - this proxy object to allow chaining\n   */\n  init(context) {\n    return Promise.resolve()\n      .then(() => {\n        let ConnectorType = require(this._connectorPath);\n        this._connector = new ConnectorType(this._settings);\n        if (this._connector.refreshCredentials) {\n          this._connector._refreshCredentials = this._connector.refreshCredentials;\n          this._connector.refreshCredentials = () => {\n            return this._refreshCredentials();\n          };\n        }\n        let methods = filter(Object.getOwnPropertyNames(Object.getPrototypeOf((this._connector))), (property) => {\n          if (property.startsWith('_') || property === 'receiveBounce' || this[property] || property === 'constructor') {\n            return false;\n          } else {\n            return true;\n          }\n        });\n        this._logger.info({\n          connector: this._connector,\n          methods\n        }, 'mapping methods');\n        methods.forEach((method) => {\n          /**\n           * also has all methods of underlying connector\n           */\n          this[method] = (...params) => {\n            this._logger.info('proxying method ' + method);\n            if (typeof this._connector[method] !== 'function') {\n              let methodType = typeof this._connector[method];\n              this._logger.warn({\n                methodType\n              }, 'tried to call an unsupported method');\n              throw new errors.connector.request.UnsupportedError(method + ' method unsupported');\n            }\n            return this._connector[method].apply(this._connector, params);\n          };\n        });\n        if (context.bucket &&\n          context.bucket.meta &&\n          context.bucket.meta.authToken &&\n          context.bucket.meta.authToken[this._connectorSetting.key]) {\n          return this.authorize(context.bucket.meta.authToken[this._connectorSetting.key])\n            .catch((err) => {\n              this._logger.error(err);\n              if (err instanceof errors.connector.request.InvalidError) {\n                return this;\n              } else {\n                throw err;\n              }\n            });\n        } else {\n          return this;\n        }\n      });\n  }\n\n  /**\n   * authorize the underlying connector\n   * @param {Authorization|String} token - either the authorization object or a bouncer token key\n   * @returns {Promise<ConnectorProxy>} - this\n   */\n  authorize(token) {\n    if (typeof this._connector.authorize !== 'function') {\n      return Promise.resolve(this);\n    }\n    if (typeof token === 'string') {\n      return BouncerToken.findOneAsync({\n        key: token\n      }).then((bouncerToken) => {\n        if (!bouncerToken) {\n          throw new errors.connector.request.InvalidError('the authorization token provided is not valid');\n        }\n        this._bouncerToken = bouncerToken;\n        return this._connector.authorize(new Authorization(bouncerToken));\n      }).then(() => {\n        return this;\n      });\n    } else {\n      this._bouncerToken = token;\n      return Promise.resolve(this._connector.authorize(token))\n        .then(() => {\n          return this;\n        });\n    }\n  }\n}\n\nexport\ndefault ConnectorProxy;\n\n/**\n * @external {ConnectorSetting} https://github.com/hoist/hoist-model/blob/master/lib/models/connector_setting.js\n */\n/**\n * @external {Context} https://github.com/hoist/hoist-context/blob/master/lib/index.js\n */\n"],"sourceRoot":"/source/"}